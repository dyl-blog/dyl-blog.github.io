<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性 DP &amp; 区间 DP &amp; 树（环）形 DP 总结</title>
    <link href="/2025/08/10/%E7%BA%BF%E6%80%A7-DP-%E5%8C%BA%E9%97%B4-DP-%E6%A0%91%EF%BC%88%E7%8E%AF%EF%BC%89%E5%BD%A2-DP-%E6%80%BB%E7%BB%93/"/>
    <url>/2025/08/10/%E7%BA%BF%E6%80%A7-DP-%E5%8C%BA%E9%97%B4-DP-%E6%A0%91%EF%BC%88%E7%8E%AF%EF%BC%89%E5%BD%A2-DP-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1>一、线性 DP 总结</h1><div class="note note-warning">            <p><strong>WARNING</strong></p><p>要认真阅读哦！</p>          </div><h2 id="1-定义">1. 定义</h2><p>线性动态规划是一种动态规划方法，它在状态转移时具有线性的特征。线性 DP 通常适用于那些线性的问题，它的状态<strong>通常</strong>并没有很复杂，<strong>一般</strong>状态转移方程也很简单。<strong>但不排除特殊情况。</strong></p><div class="note note-info">            <p><strong>INFO</strong></p><p>接下来我的总结将通过常规做题时思考的顺序进行总结。</p>          </div><h2 id="2-通用状态、答案、初值、转移与时间复杂度">2. 通用状态、答案、初值、转移与时间复杂度</h2><h3 id="状态">状态</h3><p>线性 DP 通常在定义状态时会设一个数组 $dp$，表示在目前第 $i$ 个阶段的最优解。</p><div class="note note-success">            <p><strong>SUCCESS</strong></p><p>令 $dp_i$ 表示（在目前第 $i$ 个阶段的最优解）。</p>          </div><h3 id="答案">答案</h3><p>由于状态时在目前第 $i$ 个阶段的最优解，所以答案通常是 $dp_n$，也就是算法进行到最后一个阶段的最优解。</p><h3 id="初值">初值</h3><p>初值的设定并没有常规的设定，通常根据题目的一些要求及特殊性质进行设定。</p><p>例如最长上升子序列这一问题，根据这一题目的要求，就要设 $dp_i=1\ (i\in [1,n])$。</p><p>但对于大部分题目来说，设 $dp_0=0$ 即可。</p><h3 id="转移">转移</h3><div class="note note-warning">            <p><strong>WARNING</strong></p><p>转移时动态规划做题时思考的最重要步骤，如果你推导不出转移方程，那么极有可能时状态定义错误。</p>          </div><p>根据动态规划的最优子结构特性得出转移方程是需要依赖于前面的若干状态，而线性 DP 的转移具有线性的特征，所以转移方程通常形如 $dp_i=\text f(\ \ \ \ \ \dots\ \dots\ \ \ \ \ )$。其中 $f$ 是某个函数，表示如何从前面的一个或多个状态得到当前状态的最优解。特殊的，其中一位的状态只是一个阶段的的情况，</p><h3 id="时间复杂度分析">时间复杂度分析</h3><p>由于线性 DP 的转移通常是线性的，所以复杂度为 $O(1)$。但如果在转移时加入一些函数，则计算时间复杂度是需要考虑到这些函数。</p><h1>二、区间 DP 总结</h1><div class="note note-warning">            <p><strong>WARNING</strong></p><p>难度逐渐在提升哦！</p>          </div><h2 id="1-定义-2">1. 定义</h2><p>区间 DP 是线性动态规划的扩展，主要处理一些<strong>区间合并</strong>等问题。它在分阶段地划分问题时，与<strong>阶段中元素出现的顺序</strong> 和 <strong>由前一阶段的哪些元素合并而来</strong>有很大的关系。</p><h2 id="2-性质">2. 性质</h2><p>区间 DP 有以下特点：</p><p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p><p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p><p><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p><h2 id="3-通用状态、答案、初值、转移、时间复杂度与代码">3. 通用状态、答案、初值、转移、时间复杂度与代码</h2><h3 id="状态-2">状态</h3><p>由于区间 DP 求解的是区间合并的问题，则状态通常是：令 $dp_{i,j}$ 表示区间 $[i,j]$ 的最优解（所有元素合并能获得的价值的最大值）。</p><div class="note note-warning">            <p><strong>WARNING</strong></p><p>在需要时可以在数组增加维度。</p>          </div><h3 id="答案-2">答案</h3><p>区间 DP 的答案必然是 $[1,n]$ 区间的答案，所以答案为 $dp_{1,n}$。</p><h3 id="初值-2">初值</h3><p>初值的设定并没有常规的设定，通常根据题目的一些要求及特殊性质进行设定。</p><div class="note note-success">            <p><strong>SUCCESS</strong></p><p>对于大部分题目，设 $dp_{0,0}=0$ 即可。</p>          </div><h3 id="转移-2">转移</h3><p>由于大多数区间 DP 求解的是区间合并的问题，容易得出 $dp_{i,j}=\max { f_{i,k}+f_{k+1,j}+cost }$，其中 $cost$ 为将这两组元素合并起来的价值。</p><h3 id="时间复杂度分析-2">时间复杂度分析</h3><p>由于区间 DP 的转移通常是需要三重循环的，所以基础复杂度为 $O(n^3)$。</p><div class="note note-warning">            <p><strong>WARNING</strong></p><p>但如果在转移时加入一些函数，则计算时间复杂度是需要考虑到这些函数。</p>          </div><div class="note note-warning">            <p><strong>WARNING</strong></p><p>区间 DP 时间复杂度和空间复杂度均较高，请谨慎使用。</p>          </div><h3 id="代码">代码</h3><figure class="highlight c++"><figcaption><span>lines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> dp[N][N];<span class="hljs-comment">//dp[i][j] 表示区间 [i,j] 的最优解（所有元素合并能获得的价值的最大值）</span><br><br><span class="hljs-comment">// 初始化长度为 1 的区间</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>dp[i][i]=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 单个元素通常代价为m0</span><br>&#125;<br><br><span class="hljs-comment">// 按区间长度从小到大计算（长度从 2 到 n）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++) &#123;<br><span class="hljs-comment">// 区间起点 i：从 1 到 n-len+1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n-len<span class="hljs-number">+1</span>;i++) &#123;<br><span class="hljs-type">int</span> j=i+len<span class="hljs-number">-1</span>;  <span class="hljs-comment">//区间终点 j</span><br>dp[i][j]=INT_MAX/INT_MIN;   <span class="hljs-comment">// 初始化为极 大/小 值（求最 小/大 值时）</span><br><br><span class="hljs-comment">// 尝试所有分割点 k（i&lt;=k&lt;j）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=i;k&lt;j;k++) &#123;<br><span class="hljs-comment">// 当前分割的总代价 = 左区间代价 + 右区间代价 + 分割代价</span><br><span class="hljs-type">int</span> cur=dp[i][k]+dp[k<span class="hljs-number">+1</span>][j]+<span class="hljs-built_in">cost</span>(i,k,j);<br><br><span class="hljs-comment">// 更新最优解（求最大值时用 max）</span><br>dp[i][j]=min/<span class="hljs-built_in">max</span>(dp[i][j],cur);<br>&#125;<br>&#125;<br>&#125;<br><br>cout&lt;&lt;dp[<span class="hljs-number">1</span>][n];<span class="hljs-comment">//输出答案（通常为 [1,n] 的答案）</span><br></code></pre></td></tr></table></figure><h1>三、树（环）形 DP 总结</h1><div class="note note-warning">            <p><strong>WARNING</strong></p><p>本部分虽然题目叫“树（环）形 DP 总结”，但是主要总结树形 DP。</p>          </div><h2 id="1-定义-3">1. 定义</h2><p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。</p><h2 id="2-通用状态、答案、初值、转移、时间复杂度与代码">2. 通用状态、答案、初值、转移、时间复杂度与代码</h2><h3 id="通用状态">通用状态</h3><div class="note note-warning">            <p><strong>WARNING</strong></p><p>树形 DP 主要关注以（$\ \ \ \ \ \ \ \ \ $）为根的子树。</p>          </div><h3 id="状态-3">状态</h3><p>通常定义 $dp_{u,k}$ 表示以节点 $u$ 为根的子树中，在某种状态 $k$ 下的最优解。</p><h3 id="答案-3">答案</h3><p>通常是根节点在特定状态下的最优解，即 $\text{best}(dp_{root,k})$。其中 $\text{best}$ 函数为求最优解函数，通常为 $\max$ 或 $\min$。</p><h3 id="初值-3">初值</h3><p>对叶子节点，根据具体问题设置初始状态值。</p><h3 id="转移-3">转移</h3><p>对于非叶子节点，结合子节点的状态计算当前节点的状态，通常是 $dp_{u,\dots}=$ 结合 $dp_{v,\dots}$。</p><h3 id="时间复杂度">时间复杂度</h3><p>通常为 $O(n)$ 或 $O(n\times k)$，其中 $n$ 是节点数，$k$ 是状态数。</p><h3 id="代码-2">代码</h3><figure class="highlight c++"><figcaption><span>lines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; tree[N];<span class="hljs-comment">//使用邻接表构建树结构 </span><br><span class="hljs-type">int</span> dp[N][K]; <span class="hljs-comment">//其中 N 为最大节点数，K 为最大状态数（通常为 2，因为通常状态只有 0/1）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id,<span class="hljs-type">int</span> f)</span> </span>&#123;<span class="hljs-comment">//其中 id 为当前搜索的节点，f 为 id 节点的父节点 </span><br><span class="hljs-comment">//初值设定</span><br><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// ......</span><br><br><span class="hljs-comment">//转移：遍历 id 的子节点 son </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> son:tree[id]) &#123;<br><span class="hljs-keyword">if</span>(son==f) &#123;<span class="hljs-comment">//如果儿子等于父亲，无效遍历 </span><br><span class="hljs-keyword">continue</span>;<br>&#125; <br><span class="hljs-built_in">dfs</span>(son,id);<span class="hljs-comment">//继续搜索 </span><br><br><span class="hljs-comment">//转移：通常分 k 种情况讨论</span><br>dp[id][k1]=......;<br>dp[id][k2]=......;<br>......<br>dp[id][kn]=......; <br>&#125;<br>&#125; <br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);<span class="hljs-comment">//搜索从根节点开始，所以通常 id 初值为 0，根节点没有父节点，所以 f 为不存在的节点 -1 </span><br></code></pre></td></tr></table></figure><h1>四、动态规划优化技巧</h1><div class="note note-success">            <p><strong>SUCCESS</strong></p><p>如果不想要你的代码 TLE 或 MLE，那么就来看吧！</p>          </div><h2 id="1-状态定义优化">1. 状态定义优化</h2><p>状态定义对于整个动态规划的思考过程有着无比重要的作用，修改状态定义会完全改变动态规划的思考思路，约等于“从头开始”。令人比较头疼的是，这类优化大多不具有通用性，即不能很套路地应用于多个题目中。因此，下文将从一个经典的例题出发，力求提供思路上的启发。</p><h3 id="例（最长公共子序列-LCS）">例（最长公共子序列 LCS）</h3><div class="note note-info">            <p><strong>题目大意</strong></p><p>给定两个长度分别为 $n,m$ 且仅由小写字母构成的字符串 $A,B$, 求 $A,B$ 的最长公共子序列。$n\le 10^6，m\le 10^3$</p>          </div><h4 id="朴素的解法">朴素的解法</h4><p>定义状态 $f_{i,j}$ 为 $A$ 的前 $i$ 位与 $B$ 的前 $j$ 位最长公共子序列，则有<br>$$<br>dp_{i,j}= \begin{cases} \max{dp_{i-1,j},dp_{i,j-1}} &amp; ,A_i \neq B_j \ \ dp_{i-1,j-1}+1 &amp; ,A_i = B_j \end{cases}<br>$$</p><img src="/2025/08/10/%E7%BA%BF%E6%80%A7-DP-%E5%8C%BA%E9%97%B4-DP-%E6%A0%91%EF%BC%88%E7%8E%AF%EF%BC%89%E5%BD%A2-DP-%E6%80%BB%E7%BB%93/latex-1.svg" class="" title="dp_{i,j}&#x3D; \begin{cases} \max\{dp_{i-1,j},dp_{i,j-1}\} &amp; ,A_i \neq B_j \\ dp_{i-1,j-1}+1 &amp; ,A_i &#x3D; B_j \end{cases}"><p>上述做法的时间复杂度 $O(nm)$，无法通过本题。</p><h4 id="更优的解法">更优的解法</h4><p>我们仔细一想，发现了一个性质：最终答案不会超过 $m$。</p><p>我们又仔细一想，发现 LCS 满足贪心的性质。</p><p>更改状态定义 $f_{i,j}$ 为与 $B$ 前 $i$ 位的最长公共子序列长度为 $j$ 的 $A$ 的最短前缀长度（即将朴素做法的答案与第一维状态对调）</p><p>可以通过预处理 $A$ 的每一位的下一个 $a,b,\cdots,z$ 的出现位置进行 $O(1)$ 的顺推转移。</p><p>复杂度 $O(m^2+26n)$，可以通过本题。</p><h2 id="2-转移优化（单调队列-单调栈优化）">2. 转移优化（单调队列 / 单调栈优化）</h2><p>如果状态定义已经不能再优化，那么可以考虑优化转移。</p><p>动态规划优化转移的方法有很多，这里主要介绍单调队列 / 单调栈优化。</p><h3 id="引入">引入</h3><p>单调队列主要用于维护两端指针单调不减的区间最值，而单调栈则主要用于维护前/后第一个大于/小于当前值的数。</p><div class="note note-warning">            <p><strong>WARNING</strong></p><ul><li><p>求最小值要维护 <strong>单调递增/不减</strong> 的单调队列/单调栈，反之亦然。</p></li><li><p>维护单调递增/递减比较时用 <strong>小于等于/大于等于</strong>，维护单调不减/不增比较时用 <strong>小于/大于</strong>。</p></li></ul>          </div><h3 id="单调队列优化具体步骤">单调队列优化具体步骤</h3><ul><li><p>加入所需元素：向单调队列重复加入元素直到当前元素达到所求区间的右边界，这样就能保证所需元素都在单调队列中。</p></li><li><p>弹出越界队首：单调队列本质上是维护的是所有已插入元素的最值，但我们想要的往往是一个区间最值。于是我们弹出在左边界外的元素，以保证单调队列中的元素都在所求区间中。</p></li><li><p>获取最值：直接取队首作为答案即可。</p></li></ul><h3 id="单调栈优化具体步骤">单调栈优化具体步骤</h3><ul><li><p>弹出非法栈顶：通过比较当前元素与栈顶的大小，弹出不满足单调栈性质的栈顶。以单调递增的栈（即栈顶最大，维护最小值）为例，将所有大于等于当前元素的栈内元素全部弹出。</p></li><li><p>加入当前元素：将当前元素入栈即可。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>文章</tag>
      
      <tag>信息学C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
